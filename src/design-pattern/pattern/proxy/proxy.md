# 代理模式

> [!WARNING] 累了, 空了再复盘一下动态代理

[参考文章](https://refactoringguru.cn/design-patterns/proxy)

> 亦称: Proxy

代理模式是一种[结构型设计模式](../pattern.md#结构型模式)

允许给木边对象提供替代品或者占位符, 代理可以控制目标对象的访问, 并可以在访问前后添加一些额外的操作

## 场景

小宇有一个非常庞大的应用, 这个应用非常占用内存, 但是并不是总是需要它, 可以在实际需要的时候在进行初始化, 那么在每个初始化的地方都需要进行延时初始化, 这样会产生很多无用代码

## 解决办法

代理模式建议创建一个跟原始对象对象实现相同接口的对象, 并保留对原始对象的引用, 代理对象在收到请求后会将请求处理后在转发给原始对象, 并将所有工作委派给原始对象

## 与[装饰器模式](../decorator/decorator.md)的区别

代理可以延迟创建原对象(虚拟代理), 而装饰器一般都在初始化时就会确定原对象

代理一般适用于控制对目标对象的访问, 装饰器一般用于对行为的增强

代理通常不会形成责任链, 而这对于装饰器来说很常见

## 结构

> 引用自: https://refactoringguru.cn/design-patterns/proxy

![structure](./structure-indexed.png)

1. 服务接口 （Service Interface） 声明了服务接口。 代理必须遵循该接口才能伪装成服务对象。

2. 服务 （Service） 类提供了一些实用的业务逻辑。

3. 代理 （Proxy） 类包含一个指向服务对象的引用成员变量。 代理完成其任务 （例如延迟初始化、 记录日志、 访问控制和缓存等） 后会将请求传递给服务对象。 通常情况下， 代理会对其服务对象的整个生命周期进行管理。

4. 客户端 （Client） 能通过同一接口与服务或代理进行交互， 所以你可在一切需要服务对象的代码中使用代理。

## 贴个代码

<<< @/src/design-pattern/pattern/proxy/proxy.ts
