# 解释器模式

> [!WARNING] 这个模式不常用, 理解的不是很深

解释器模式是一种[行为型设计模式](../pattern.md#行为型模式)

定义一种语言的文法表示, 并构建一个解释器来解释该语言中的句子

我理解的是对一种特殊对象的特殊行为的定义和解释, 比如用来解释**抽象语法树**其中的节点

## 场景

小宇开发了一款商城引用, 在设计优惠券时遇到了问题, 怎么样设计的优惠券才更加有利于迭代, 因为商城后面会根据活动的不同而提供不同的优惠券和优惠规则, 如果只是在计算价格时笼统的写算法来计算优惠券, 这样在后续新增优惠券时会修改原有代码, 这样不符合开闭原则

## 解决方案

解释器模式建议给特殊的对象(表达式 Expression)定义一个**解释方法**, 用于**解释这个对象的行为**

在上面的例子中, 可以将优惠券定义为一个表达式, 并给每个优惠券提供解释方法用来解释这个优惠券的规则

## 结构

```lua
               +----------------------------+
               |   AbstractExpression       |<<interface>>
               +----------------------------+
               | + interpret(context): any  |
               +----------------------------+
                          ▲
          +---------------+-----------------+
          |                                 |
+--------------------------+   +-----------------------------+
|   TerminalExpression     |   |   NonTerminalExpression     |
+--------------------------+   +-----------------------------+
| + interpret(context):any |   | + interpret(context): any   |
+--------------------------+   | - expressions: Expression[] |
                               +-----------------------------+

               +----------------------------+
               |         Context            |
               +----------------------------+
               |   <数据结构、状态信息>     |
               +----------------------------+

```

- 抽象表达式(Abstract Expression), 抽象接口或者抽象类, 定义一个解释方法, 所有的表达式都要实现这个接口

- 终结表达式(Terminal Expression), 抽象表达式的子类, 并且**不依赖于其他表达式**, 能够直接给出结果

例如: 判断总价是否大于 10 没有依赖其他的表达式, 所以是终结符表达式

- 非终结表达式(Non Terminal Expression), 抽象表达式的子类, 需要依赖于其他表达式

例如: 判断 '新用户' 并且 '总结大于 10' 是非终结符表达式, 需要**依赖其他表达式**才能给出结果

- 上下文(Context), 存储整个结构的必要信息

例如: 当前用户是否是新用户, 当前用户购物的总价是多少信息都存储在上下文中

## 贴个代码

<<< @/src/design-pattern/pattern/interpreter/interpreter.ts
