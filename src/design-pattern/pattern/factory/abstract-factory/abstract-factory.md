# 抽象工厂模式

[参考文章](https://refactoringguru.cn/design-patterns/abstract-factory)

> 亦称： Abstract Factory

抽象工厂模式是一种[创建型设计模式](../../pattern.md#创建型模式)

> [!TIP] 这个模式跟我想象中的不一样, 我以为的抽象工厂模式原来只是面向对象的继承与多态

## 场景

小宇开发开发了一款 ui 框架, 里面有**很多组件**, 每个组件都有 **material 风格**和 **hollowed-out 风格**

现在在**风格统一**上出现了问题

因为在每次使用组件的时候, 如果不想出现这两种**风格混用**的情况, 就需要在使用时**手动指定风格**, 增加了**心智负担**

那就**重构!!!**

## 解决方法

在理解抽象工厂模式之前, 我们先对一些名词做一些解释

- 产品族: 功能相关联的**一系列产品** (如上文的 ui 组件)
- 产品等级: **产品族**的不同**形态** (如上文的 material 和 hollowed-out 风格)
- 抽象产品: 对**单一产品**的抽象 (相当于通过抽象产品实现的组件都属于**同一产品类型**, 比如 button 组件实例不管什么风格它始终都是 button 组件)
- 具体产品: 抽象产品的具体实现
- 抽象工厂: 对**单一产品等级**的抽象 (就是对上文的 material 和 hollowed-out 风格的抽象, 下文会解释抽象这个有什么用)
- 具体工厂: 抽象工厂的具体实现

首先, 抽象工厂模式建议为产品族的**所有产品**都定义一个抽象接口, 也就是上文说的抽象产品, 所有的具体产品都实现这个接口

抽象工厂需要包含**构造产品族**的接口, 如果 `createButton` 或者 `createInput` 等, 这些方法返回**对应的抽象产品**

抽象工作我们就完成了

> 抽象工厂 -> 抽象产品族

接下来, 根据抽象工厂生成具体工厂

例如可以定义 material 和 hollowed-out 风格的具体工厂 `materialFactory` 和 `hollowedOutFactory`

这两个具体工厂都实现**构造对应具体产品族**的方法

> 具体工厂 -> 具体产品族

这样我们的代码就可以写成这样

<<< @/src/design-pattern/pattern/factory/abstract-factory/abstract-factory.ts
