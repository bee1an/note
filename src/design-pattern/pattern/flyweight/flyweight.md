# 享元模式

[参考文章](https://refactoringguru.cn/design-patterns/flyweight)

> 亦称: 缓存、Cache、Flyweight

享元模式是一种[结构型设计模式](../pattern.md#结构型模式)

摒弃了每个对象中保存数据的方法, 通过共享内存中相同的状态来**减少内存的占用**

享元模式是一种**优化手段**

## 场景

小宇开发了一款游戏, 起初游戏运行的能流畅, 当怪物越来越多时, 游戏就变得越来越卡顿, 直至崩溃

这与游戏的怪物渲染有关, 所有的怪物都是一个独立类, 尽管它们在外观上并没有任何区别, 当怪物数量急剧增加时, 内存告急

## 解决方法

对象的**常量数据被称为内部状态**, 其他对象只能读取但是不能修改它的值

能被其他对象从**外面修改的状态成为外部状态**

享元模式建议将**内部状态单独存储**到一个对象中, 方便在不同的场景下**重用**, 那么你可以能会问外部状态存储在哪里呢

这时候就需要一个情景对象来**管理外部状态并且包含对享元的引用**, 这样一个情景就可以表示一个原始对象的所有的状态了

我们还需要一个管理享元的享元工厂, 其中包含所有已有**享元对象的缓存池**, 暴露一个获取享元对象的方法, 如果该方法没有找到享元对象, 则会新建一个并保存到缓存池中

## 实际开发中的例子

`pixijs` 中如果资源的 `src` 相同那么会从基础纹理缓存中获取已有的纹理并返回

## 结构

> 引用自: https://refactoringguru.cn/design-patterns/flyweight

![structure](./structure-indexed.png)

1. 享元模式只是一种优化。 在应用该模式之前， 你要确定程序中存在与大量类似对象同时占用内存相关的内存消耗问题， 并且确保该问题无法使用其他更好的方式来解决。

2. 享元 （Flyweight） 类包含原始对象中部分能在多个对象中共享的状态。 同一享元对象可在许多不同情景中使用。 享元中存储的状态被称为 “内在状态”。 传递给享元方法的状态被称为 “外在状态”。

3. 情景 （Context） 类包含原始对象中各不相同的外在状态。 情景与享元对象组合在一起就能表示原始对象的全部状态。

4. 通常情况下， 原始对象的行为会保留在享元类中。 因此调用享元方法必须提供部分外在状态作为参数。 但你也可将行为移动到情景类中， 然后将连入的享元作为单纯的数据对象。

5. 客户端 （Client） 负责计算或存储享元的外在状态。 在客户端看来， 享元是一种可在运行时进行配置的模板对象， 具体的配置方式为向其方法中传入一些情景数据参数。

6. 享元工厂 （Flyweight Factory） 会对已有享元的缓存池进行管理。 有了工厂后， 客户端就无需直接创建享元， 它们只需调用工厂并向其传递目标享元的一些内在状态即可。 工厂会根据参数在之前已创建的享元中进行查找， 如果找到满足条件的享元就将其返回； 如果没有找到就根据参数新建享元。

## 贴个代码

<<< @/src/design-pattern/pattern/flyweight/flywieght.ts
