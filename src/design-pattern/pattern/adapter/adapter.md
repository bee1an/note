# 适配器模式

[参考文章](https://refactoringguru.cn/design-patterns/adapter)

> 亦称: 封装器模式、Wrapper、Adapter

适配器模式是一种[结构型设计模式](../pattern.md#结构型模式)

使接口不兼容的对象能够相互合作

这里的合作并不是指它们直接可以相互调用的意思, 而是他们可以通过适配器提供相同的接口, 在使用他们的地方可以互相替换

## 场景

小宇在文件上传时需要给文件进行加密操作, 所以小宇引入了一个第三方库, 但是理想总是丰满的, 第三方库提供的接口跟我们自己的**接口不兼容**

这时候就需要将第三方库的接口兼容我们自己接口

## 解决方法

适配器模式建议创建一个适配器类, 这个适配器类**实现或继承了现有对象的接口**(上例中的我们自己的接口就是现有对象的接口), **聚合**了目标对象接口(上例中的第三方库的接口)

在使用现有对象的地方可以**安全**的使用适配器(因为他们实现了相同的接口)

调用适配器的方法时, 适配器会将格式转换为与**目标对象适配**的格式

你可以将现有对象的特殊行为抽离为独特的抽象接口, 适配器实现这个接口, 这样就可以不用实现对于适配器来讲没用的方法了

### 另一种适配器

另一种适配器模式是**类适配器**, 适配器不聚合目标对象而是**继承**目标对象, 对于现有对象, 如果编程语言**支持多类继承**那么则继承现有对象, 如果不支持, 那么只能实现现有对象的接口, 这种模式**不满足**[合成复用原则](../../principle/composite-reuse/composite-reuse.md), 而且条件比较苛刻(要求支持多类继承或者现有对象有抽象接口), 所以**不太推荐**

## 现实中的例子

我记得在我高中的时候手机开始普遍取消 3.5 毫米耳机孔, 那个时候的耳机基本上都是这个接口的, 这催生了很多生产 3.5 毫米耳机孔转 type-c 的厂商

这里的转接口就相当于一个适配器, 因为是给耳机提供了一个**新接口**

## 结构

![structure](./structure-adapter.png)

1. 客户端 （Client） 是包含当前程序业务逻辑的类。

2. 客户端接口 （Client Interface） 描述了其他类与客户端代码合作时必须遵循的协议。

3. 服务 （Service） 中有一些功能类 （通常来自第三方或遗留系统）。 客户端与其接口不兼容， 因此无法直接调用其功能。

4. 适配器 （Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。

5. 客户端代码只需通过接口与适配器交互即可， 无需与具体的适配器类耦合。 因此， 你可以向程序中添加新类型的适配器而无需修改已有代码。 这在服务类的接口被更改或替换时很有用： 你无需修改客户端代码就可以创建新的适配器类。

## 与装饰器的区别

适配器强调给目标对象**添加**一个新**接口**, 而装饰器强调**增强**目标对象的**行为**

因为适配器给目标对象添加了新接口, 所以适配器与目标对象的类型不一致, 但是装饰器只是扩展了目标对象的行为, 并没有对接口进行修改, 所以存在**递归组合**(给装饰器添加装饰器)

在上例中, 如果是 type-c 转 type-c 的话, 这相当于一个装饰器

## 贴个代码

<<< @/src/design-pattern/pattern/adapter/adapter.ts
