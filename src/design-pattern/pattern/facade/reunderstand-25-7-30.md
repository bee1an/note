# 重新理解 25-7-30

我之前对这个模式的理解和现在差不多, 这里再记录一次更形象的理解

还是用视频编辑器的例子

假设这个视频编辑器会被打包, 那么提供给用户的生成元素的类就会很多

如果用户想要创建视频和图片元素, 那么可能需要这样

```ts
import { Video, Image } from 'lib'
```

但是, 命令不一定就是 `Video` 和 `Image` 这样简单的单词

比如现在用户想创建一个动图, 那么动图的类是 `MotionImage` 还是 `AnimatedImage` 就不确定了, 徒增了心智负担

让用户访问复杂的类是不好的行为, 所有我们需要抛出一个简单的接口

如果抛出一个 `creator` 函数, 第一个参数就是可以创建一个元素类型, 其他参数根据需要配置

```ts
export function creator(type: ElementType, ...args: any[]) {
	// ...
}
```

这样就可以根据 `ElementType` 知道可以创建哪些元素, 这样用户只需要知道一个 `creator` 函数就可以了, 具体内部调用了哪些类用户不需要关心

这个 `creator` 函数就是外观

核心: **"封装复杂，提供简单"**

缺点:

- 违背了单一职责, 外观知道的事情和要干的事情太多了
- 不符合开闭原则, 如果需要增加一个新的元素类型, 那么就需要修改 `creator` 函数
