# 中介者模式

[参考文章](https://refactoringguru.cn/design-patterns/mediator)

> 亦称: 调解人、控制器、Intermediary、Controller、Mediator

中介者模式是一种[行为型设计模式](../pattern.md#行为型模式)

旨在减少对象间的复杂依赖关系, 显示对象间直接交互, 迫使它们通过中介者对象进行合作

## 场景

小宇正在开发一个表单信息收集弹框, 这弹框由许多组件组成, 比如输入框, 单选框, 多选框等

某些组件之间在业务上会有依赖关系, 比如在选择性别复选框时, 如果选择了其他性别, 那么就会出现一个输入框来输入性别(这个例子是不是有点[逻辑变态](https://zh.wikipedia.org/wiki/LGBT)了)

如果直接在组件中处理这些逻辑, 那么如果想在其他地方复用这个复选框的话会'赠送'一个显示输入框逻辑

那就**重构**!!!

## 解决方法

中介者模式**禁止**组件(component)之间**直接通信**, 而是将逻辑代码封装到一个名为中介者(mediator)的对象中, 通过中介者对象**间接合作**, 最终, 所有的对象将仅依赖于一个中介者对象

可以将中介者抽取为通用接口, 组件仅依赖于中介者接口, 接口中声明一个通用的通知方法, 这样就可以根据实际情况依赖于不同的实际中介者

## 结构

![structure](./structure-indexed.png)

1. 组件 （Component） 是各种包含业务逻辑的类。 每个组件都有一个指向中介者的引用， 该引用被声明为中介者接口类型。 组件不知道中介者实际所属的类， 因此你可通过将其连接到不同的中介者以使其能在其他程序中复用。

2. 中介者 （Mediator） 接口声明了与组件交流的方法， 但通常仅包括一个通知方法。 组件可将任意上下文 （包括自己的对象） 作为该方法的参数， 只有这样接收组件和发送者类之间才不会耦合。

3. 具体中介者 （Concrete Mediator） 封装了多种组件间的关系。 具体中介者通常会保存所有组件的引用并对其进行管理， 甚至有时会对其生命周期进行管理。

4. 组件并不知道其他组件的情况。 如果组件内发生了重要事件， 它只能通知中介者。 中介者收到通知后能轻易地确定发送者， 这或许已足以判断接下来需要触发的组件了。 对于组件来说， 中介者看上去完全就是一个黑箱。 发送者不知道最终会由谁来处理自己的请求， 接收者也不知道最初是谁发出了请求。

## 贴个代码

<<< @/src/design-pattern/pattern/mediator/mediator.ts
