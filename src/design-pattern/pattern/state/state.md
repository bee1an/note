# 状态模式

[参考文章](https://refactoringguru.cn/design-patterns/state)

> 亦称: State

状态模式是一种[行为型设计模式](../pattern.md#行为型模式)

能让对象内部状态改变时改变其行为

因为将工作都委派给了状态对象, 状态切换则行为也随之改变

## 场景

小宇封装了一款视频编辑器, 视频编辑器有很多种状态, 每种状态下的行为会有所差异, 例如当视频在暂停时点击播放则会播放这个视频, 加载时点击播放不会触发任何事件

我们不难发现一个问题, 就是在播放方法中可能会存在关于状态的条件语句, 在其他方法中亦是如此, 如果我们后续需要增加其他状态的判断那么就需要修改以前的代码, 例如在播放方法中判断是否加载结束

## 解决方法

状态模式与[有限状态机](https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA)的概念紧密相关

这个例子举得不是很好, 因为视频的状态基本上可能确定, 然而状态模式可以应对**状态不确定**的情况

状态模式建议给每**一个状态**都建立**一个独立的类**, 然后这些类将实现**所有状态的行为**(这个行为可以什么都不做, 但是需要定义)

上下文(Context)对象中存在一个类型为状态的属性, 这个**属性指向当前状态**对象, 并将当前状态下的**工作委派**给该对象

上下文可以**自由的切换状态**对象(这满足了状态模式中状态可以互相转换), 所有这些状态必须**实现同一个接口**, 也就是为什么上面提到这些类必须实现所有状态方法即使方法什么都不干, 用例子来讲就相当于在播放状态再次触发播放事件但是什么都不会发生一样

## 结构

> 引用自: https://refactoringguru.cn/design-patterns/state

![structure](./structure-indexed.png)

1. 上下文 （Context） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。

2. 状态 （State） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。

3. 具体状态 （Concrete States） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。

4. 上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。

## 贴个代码

<<< @/src/design-pattern/pattern/state/state.ts
