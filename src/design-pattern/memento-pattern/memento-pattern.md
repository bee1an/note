# 备忘录模式

[参考文章](https://refactoringguru.cn/design-patterns/memento)

> 亦称: 快照、Snapshot、Memento

备忘录模式是一种**行为设计模式**

允许在不暴露对象实现细节的情况下**保存和恢复**对象之前的状态

## 场景

小宇开发一款文字编辑器, 支持文字输入和删除功能, 现在需要实现**撤销**功能

在保存快照时需要获取编辑器状态, 现在如果获取这些状态快照成了一个问题

如果只是遍历这个对象从而获取所有的属性, 以后添加或者删除了成员变量, 那么对保存这个状态快照的类也需要进行相同的操作

而且外部并不是对这个对象的所有成员变量都有**访问权限**

## 解决方案

导致以上问题的原因是因为**封装 '破损'**, 一些对象试图完成超出自己的职责范围的工作, 它们侵入了其他对象的私有空间, 而不是让这些对象自己完成工作, 例如上面个所说的通过遍历来保存状态快照

备忘录模式建议将快照生成**工作委派给实际状态拥有者**的原发器(originator)对象, 这样就**不需要其他对象在外部获取**原发器对象的状态(这样就不会导致封装破损), 是不是有点像[原型模式](../prototype-pattern/prototype-pattern.md)

场景中的编辑器可以访问所有对象, 所以完全可以让编辑器**自行生成**状态快照

模式建议将快照状态存在一个名为备忘录(memento)的对象中, 除了原发器对象, 其他对象只能使用**受限的接口**与备忘录交互(为了满足迪米特法则?我也不知道), 他们可以获取快照的元数据(创建时间和操作名称等), 但是不能访问快照中原始对象的状态

我们将存放备忘录的对象成为负责人(caretaker), 它只能访问备忘录的元数据, 以及在特定的时候将特定的备忘录对象传递给原发器对象(或者像示例2一样), 因为原发器对象对备忘录有所有的访问权限, 所以它可以通过备忘录进行状态恢复

在文本编辑器的例子中, 编辑器是原发器, 需要提供生成备忘录的功能, 历史记录栈为负责人, 历史记录可以传递特定的备忘录给编辑器, 编辑器可以根据备忘录恢复到之前的状态

## 贴个代码

很遗憾, ts 并不支持嵌套类, 所以我们需要一些特殊的手段来保证负责人不能访问备忘录的状态

<<< @/src/design-pattern/memento-pattern/memento-pattern-1.ts

仔细观察会发现负责人与原发器是耦合的, 这样会的话一个原发器就会有一个负责人, 这样的代码是不够健硕的, 我们进行优化

<<< @/src/design-pattern/memento-pattern/memento-pattern.ts
